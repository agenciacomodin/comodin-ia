
import { withAuth } from 'next-auth/middleware'
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'
import { UserRole } from '@prisma/client'
import { canAccessRoute, getDashboardRoute, Permission, getRolePermissions } from './lib/permissions'
import { getAccessLevel, AccessLevel, canAccessOrganization } from './lib/hierarchy'

// Rutas que requieren autenticación
const protectedRoutes = [
  '/dashboard',
  '/conversations',
  '/contacts',
  '/settings',
  '/reports',
  '/admin',
  '/distributor',
  '/api/protected'
]

// Rutas públicas que no requieren autenticación
const publicRoutes = [
  '/',
  '/auth/login',
  '/auth/register',
  '/api/auth',
  '/api/health'
]

// Configuración de acceso por ruta y rol
const ROUTE_ACCESS_CONFIG: Record<string, {
  allowedRoles?: UserRole[]
  requiredPermissions?: Permission[]
  accessLevel?: AccessLevel
}> = {
  '/admin': {
    allowedRoles: ['SUPER_ADMIN'],
    accessLevel: AccessLevel.PLATFORM
  },
  '/distributor': {
    allowedRoles: ['DISTRIBUIDOR'],
    accessLevel: AccessLevel.MULTI_TENANT
  },
  '/dashboard': {
    allowedRoles: ['PROPIETARIO', 'AGENTE', 'SUPER_ADMIN', 'DISTRIBUIDOR'], // ✅ DISTRIBUIDOR agregado
    accessLevel: AccessLevel.ORGANIZATION
  },
  '/settings/organization': {
    requiredPermissions: [Permission.MANAGE_ORGANIZATION]
  },
  '/settings/users': {
    requiredPermissions: [Permission.MANAGE_USERS]
  },
  '/settings/billing': {
    requiredPermissions: [Permission.VIEW_BILLING]
  },
  '/api/organizations': {
    requiredPermissions: [Permission.VIEW_ALL_ORGANIZATIONS, Permission.VIEW_ORGANIZATION_SETTINGS]
  }
}

export default withAuth(
  function middleware(req: NextRequest & { nextauth: { token: any } }) {
    const { pathname } = req.nextUrl
    const token = req.nextauth?.token

    // Log para debugging en desarrollo
    if (process.env.NODE_ENV === 'development') {
      console.log(`[Middleware] ${req.method} ${pathname} - User: ${token?.email} (${token?.role})`)
    }

    // Si no hay token en rutas protegidas
    if (!token && protectedRoutes.some(route => pathname.startsWith(route))) {
      const loginUrl = new URL('/auth/login', req.url)
      loginUrl.searchParams.set('callbackUrl', req.url)
      return NextResponse.redirect(loginUrl)
    }

    // Si hay token, verificar acceso específico
    if (token) {
      const userRole = token.role as UserRole
      const accessLevel = getAccessLevel(userRole)
      
      // ✅ SUPER_ADMIN tiene acceso completo a todo
      if (userRole === 'SUPER_ADMIN') {
        console.log(`[Middleware] SUPER_ADMIN access granted for ${pathname}`)
        
        // Agregar headers de contexto para APIs
        if (pathname.startsWith('/api/')) {
          const response = NextResponse.next()
          response.headers.set('x-user-id', token.sub!)
          response.headers.set('x-user-role', userRole)
          response.headers.set('x-organization-id', token.organizationId)
          response.headers.set('x-access-level', accessLevel)
          return response
        }
        
        return NextResponse.next()
      }
      
      // Verificar acceso a rutas específicas para otros roles
      const routeConfig = ROUTE_ACCESS_CONFIG[pathname] || 
                         Object.entries(ROUTE_ACCESS_CONFIG).find(([route]) => 
                           pathname.startsWith(route)
                         )?.[1]

      if (routeConfig) {
        // Verificar roles permitidos
        if (routeConfig.allowedRoles && !routeConfig.allowedRoles.includes(userRole)) {
          console.log(`[Middleware] Access denied - Role ${userRole} not allowed for ${pathname}`)
          return NextResponse.redirect(new URL(getDashboardRoute(userRole), req.url))
        }

        // Verificar nivel de acceso
        if (routeConfig.accessLevel) {
          const userAccessLevel = getAccessLevel(userRole)
          const requiredAccessLevel = routeConfig.accessLevel
          
          // Definir orden de niveles de acceso (menor número = menos acceso)
          const accessLevelOrder = {
            [AccessLevel.LIMITED]: 1,
            [AccessLevel.ORGANIZATION]: 2,
            [AccessLevel.MULTI_TENANT]: 3,
            [AccessLevel.PLATFORM]: 4
          }
          
          if (accessLevelOrder[userAccessLevel] < accessLevelOrder[requiredAccessLevel]) {
            console.log(`[Middleware] Access denied - Insufficient access level for ${pathname}`)
            return NextResponse.redirect(new URL(getDashboardRoute(userRole), req.url))
          }
        }

        // Verificar permisos específicos usando la función existente
        const userPermissions = getRolePermissions(userRole)
        if (!canAccessRoute(userPermissions, pathname)) {
          console.log(`[Middleware] Access denied - No permission for ${pathname}`)
          return NextResponse.redirect(new URL(getDashboardRoute(userRole), req.url))
        }
      }

      // Redirección de la raíz al dashboard apropiado
      if (pathname === '/') {
        const targetDashboard = getDashboardRoute(userRole)
        return NextResponse.redirect(new URL(targetDashboard, req.url))
      }

      // Middleware específico para APIs
      if (pathname.startsWith('/api/')) {
        const response = NextResponse.next()
        
        // Agregar headers de contexto de usuario
        response.headers.set('x-user-id', token.sub!)
        response.headers.set('x-user-role', userRole)
        response.headers.set('x-organization-id', token.organizationId)
        response.headers.set('x-access-level', accessLevel)
        
        return response
      }

      // Validación de acceso a organizaciones en URLs con parámetros
      const orgMatch = pathname.match(/\/organizations\/([^\/]+)/)
      if (orgMatch) {
        const targetOrgId = orgMatch[1]
        // Verificar si el usuario tiene acceso a esta organización
        if (userRole !== 'SUPER_ADMIN' && token.organizationId !== targetOrgId) {
          console.log(`[Middleware] Access denied - Cannot access organization ${targetOrgId}`)
          return NextResponse.redirect(new URL(getDashboardRoute(userRole), req.url))
        }
      }
    }

    // Continuar con la request
    return NextResponse.next()
  },
  {
    callbacks: {
      authorized: ({ token, req }) => {
        const { pathname } = req.nextUrl

        // Permitir rutas públicas sin token
        if (publicRoutes.some(route => pathname.startsWith(route))) {
          return true
        }

        // Requerir token para rutas protegidas
        if (protectedRoutes.some(route => pathname.startsWith(route))) {
          return !!token
        }

        // Por defecto, permitir acceso
        return true
      },
    },
  }
)

// Configuración de rutas que deben ser procesadas por el middleware
export const config = {
  matcher: [
    /*
     * Coincidir con todas las rutas excepto:
     * 1. /api/auth/* (rutas de autenticación de NextAuth)
     * 2. /_next/static (archivos estáticos)
     * 3. /_next/image (optimización de imágenes)
     * 4. /favicon.ico (favicon)
     * 5. Archivos estáticos (.png, .jpg, etc.)
     */
    '/((?!api/auth|_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
  ],
}
